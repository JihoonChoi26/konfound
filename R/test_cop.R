# COP standards for Coefficient of Proportionality
# test_cop calculates both versions of COP (Oster's approx & exact)

test_cop <- function(est_eff, # unstandardized
                     std_err, # unstandardized
                     n_obs,
                     n_covariates,
                     sdx,
                     sdy,
                     R2, # NOT the adjusted R2, should be the original R2
                     eff_thr = 0, # this is the unstandardized version
                     FR2max_multiplier = 1.3,
                     FR2max = 0, # NOT the adjusted R2, should be the original R2
                     to_return = "short"){
   
    ## test exampple
    # est_eff = .125
    # std_err = .050
    # n_obs = 6174
    # n_covariates = 7
    # sdx = .217
    # sdy = .991 
    # R2 = .251
    # eff_thr = 0
    # FR2max = .61
    # test_cop(est_eff = .125, std_err = .050, n_obs = 6174, n_covariates = 7,
    #          sdx = .217, sdy = .991, R2 = .251, eff_thr = 0, FR2max = .61, to_return = "short")
    # test_cop(est_eff = .125, std_err = .050, n_obs = 6174, n_covariates = 7,
    #          sdx = .217, sdy = .991, R2 = .251, eff_thr = 0, FR2max = .61, to_return = "full")
    
    
    ## prepare input
    df = n_obs - n_covariates - 3
    var_x = sdx^2
    var_y = sdy^2
    ### if the user specifies R2max directly then we use the specified R2max 
    if (FR2max == 0){FR2max = FR2max_multiplier * R2}
    var_z = sdz = 1
    
    ## now standardize 
    beta_thr = eff_thr * sdx / sdy
    beta = est_eff * sdx / sdy
    SE = std_err * sdx / sdy
    
    ## observed regression, reg y on x Given z
    tyxGz = beta / SE  ### this should be equal to est_eff / std_err
    ryxGz = tyxGz / sqrt(df + tyxGz^2)
    
    ## make sure R2 due to x alone is not larger than overall or observed R2
    if (ryxGz^2 > R2) {illcnd_ryxGz = T} else {illcond_ryxGz = F}
    
    ## calculate ryz, rxz, rxy
    ryz = rzy = cal_ryz(ryxGz, R2)
    rxz = rzx = cal_rxz(var_x, var_y, R2, df, std_err)
    rxy = ryx = cal_rxy(ryxGz, rxz, ryz)
    
    ## baseline regression model, no z (unconditional)
    eff_uncond = sqrt((var_y / var_x)) * rxy
    t_uncond = rxy * sqrt(n_obs - 2)/sqrt(1 - rxy^2)
    std_err_uncond = eff_uncond / t_uncond
    R2_uncond = rxy^2
    
    ## calculate delta_star
    delta_star = cal_delta_star(FR2max, R2, R2_uncond, est_eff, eff_thr, var_x, var_y, eff_uncond, rxz)
    
    ## now introduce cv
    sdcv = var_cv = 1
    rcvz = rzcv = 0
    v = 1 - rxz^2 # this is to simplify calculation later
    D = sqrt(FR2max - R2) # same above
    
    ## calculate rxcv & rycv implied by Oster from delta_star (assumes rcvz=0)
    rxcv_oster = rcvx_oster = delta_star * rxz * (sdcv / sdz)
    if (abs(rcvx_oster) <1 && (rcvx_oster^2/v)<1)
    {rcvy_oster = rycv_oster = 
        D * sqrt(1 - (rcvx_oster^2 / v)) + 
        (ryx * rcvx_oster) / (v * sdx) - 
        (ryz * rcvx_oster * rxz) / (v * sdz)}
    
    # Checking beta, R2, se generated by delta_star  with a regression
    verify_oster = verify_reg_Gzcv(n_obs, sdx, sdy, sdz, sdcv, 
                                   rxy, rxz, rzy, rycv_oster, rxcv_oster, rcvz)
    cov_oster = verify_oster[[11]]
    
    ### verify_oster[1] == verify_oster[4]
    ### verify_exact[2] == eff_thr
    ### verify_exact[5] == beta_thr
    
    ## calculate the exact/true rcvx, rcvy, delta
    exact_result = cal_delta_exact(ryx, ryz, rxz, beta_thr, FR2max, R2, sdx, sdz)
    rxcv_exact = rcvx_exact = as.numeric(exact_result[1])
    rycv_exact = rcvy_exact = as.numeric(exact_result[2])
    delta_exact = as.numeric(exact_result[3])
        
    # Checking beta, R2, se generated by True/Exact Delta  with a regression
    verify_exact = verify_reg_Gzcv(n_obs, sdx, sdy, sdz, sdcv, 
                                   rxy, rxz, rzy, rycv_exact, rxcv_exact, rcvz)
    ### verify_exact[1] == verify_exact[4] == FR2max
    ### verify_exact[2] == eff_thr
    ### verify_exact[5] == beta_thr

    # calculate % bias in delta comparing oster's delta_star with true delta
    delta_pctbias = 100 * (delta_star - delta_exact) / delta_exact

    # prepare some other values in the final Table (long output)
    R2_M3 = as.numeric(verify_exact[1])
    eff_x_M3 = as.numeric(verify_exact[2]) # should be equivalent or very close to eff_thr
    se_x_M3 = as.numeric(verify_exact[3])
    beta_x_M3 = as.numeric(verify_exact[9]) # should be equivalent or very close to beta_thr
    t_x_M3 = eff_x_M3 / se_x_M3 
    eff_z_M3 = as.numeric(verify_exact[4])
    se_z_M3 = as.numeric(verify_exact[5])
    eff_cv_M3 = as.numeric(verify_exact[6])
    se_cv_M3 = as.numeric(verify_exact[7])
    cov_exact = verify_exact[[11]]
    
    verify_pse_reg_M2 = verify_reg_Gz(n_obs, sdx, sdy, sdz, rxy, rxz, rzy)
    R2_M2 = as.numeric(verify_pse_reg_M2[1])
    eff_x_M2 = as.numeric(verify_pse_reg_M2[2]) # should be equivalent or very close to est_eff
    se_x_M2 = as.numeric(verify_pse_reg_M2[3]) # should be equivalent or very close to std_err
    eff_z_M2 = as.numeric(verify_pse_reg_M2[4]) 
    se_z_M2 = as.numeric(verify_pse_reg_M2[5]) 
    t_x_M2 = eff_x_M2 / se_x_M2 
    
    verify_pse_reg_M1 = verify_reg_uncond(n_obs, sdx, sdy, rxy)
    R2_M1 = as.numeric(verify_pse_reg_M1[1]) # should be equivalent or very close to rxy^2
    eff_x_M1 = as.numeric(verify_pse_reg_M1[2]) # should be equivalent or very close to rxy*sdy/sdx
    se_x_M1 = as.numeric(verify_pse_reg_M1[3]) 
    t_x_M1 = eff_x_M1 / se_x_M1 
    
    fTable <- matrix(c(R2_M1, R2_M2, R2_M3, # R2 for three reg models
                       eff_x_M1, eff_x_M2, eff_x_M3, # unstd reg coef for X in three reg  models
                       se_x_M1, se_x_M2, se_x_M3, # unstd reg se for X in three reg models
                       rxy, ryxGz, beta_x_M3, # std reg coef for X in three reg models
                       t_x_M1, t_x_M2, t_x_M3, # t values for X in three reg models
                       NA, eff_z_M2, eff_z_M3, # reg coef for Z in three reg models
                       NA, se_z_M2, se_z_M3, # se for Z in three reg models
                       NA, eff_z_M2 / se_z_M2, eff_z_M3 / se_z_M3, # t for Z in three reg models,
                       NA, NA, eff_cv_M3, # reg coef for CV in three reg models
                       NA, NA, se_cv_M3, # se for CV in three reg models
                       NA, NA, eff_cv_M3 / se_cv_M3), # t for CV in three reg models
                       nrow = 11, ncol = 3, byrow = T) 
    
    rownames(fTable) <- c("R2", "coef_X", "SE_X", "std_coef_X", "t_X",
                          "coef_Z", "SE_Z", "t_Z",
                          "coef_CV", "SE_CV", "t_CV")
    
    colnames(fTable) <- c("M1, X", "M2, X & Z", "M3, X, Z, & CV")
    
    if (to_return == "short") {
        output <- list("delta_star" = delta_star, 
                       "delta_exact" = delta_exact, 
                       "delta_pctbias" = delta_pctbias)
        return(output)
    } 
    
    if (to_return == "full") {
        output <- list("delta_star" = delta_star, 
                       "delta_exact" = delta_exact, 
                       "delta_pctbias" = delta_pctbias,
                       "cov_oster" = cov_oster,
                       "cov_exact" = cov_exact,
                       "Table" = fTable)
        return(output)
    }

}